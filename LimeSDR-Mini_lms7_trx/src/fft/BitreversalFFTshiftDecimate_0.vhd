-- generated by pyha 0.0.7
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.DataWithIndex_3.all;
    use work.DataWithIndex_0.all;
    use work.MovingAverage_0.all;
    use work.DCRemoval_0.all;
    use work.Packager_0.all;
    use work.Windower_1.all;
    use work.ShiftRegister_12.all;
    use work.StageR2SDF_12.all;
    use work.ShiftRegister_0.all;
    use work.StageR2SDF_0.all;
    use work.ShiftRegister_1.all;
    use work.StageR2SDF_1.all;
    use work.ShiftRegister_2.all;
    use work.StageR2SDF_2.all;
    use work.ShiftRegister_3.all;
    use work.StageR2SDF_3.all;
    use work.ShiftRegister_4.all;
    use work.StageR2SDF_4.all;
    use work.ShiftRegister_5.all;
    use work.StageR2SDF_5.all;
    use work.ShiftRegister_6.all;
    use work.StageR2SDF_6.all;
    use work.ShiftRegister_7.all;
    use work.StageR2SDF_7.all;
    use work.ShiftRegister_8.all;
    use work.StageR2SDF_8.all;
    use work.ShiftRegister_9.all;
    use work.StageR2SDF_9.all;
    use work.ShiftRegister_10.all;
    use work.StageR2SDF_10.all;
    use work.ShiftRegister_11.all;
    use work.StageR2SDF_11.all;
    use work.R2SDF_1.all;
    use work.ConjMult_0.all;
    use work.RAM_0.all;


package BitreversalFFTshiftDecimate_0 is
    type self_t is record
        state: boolean;
        mem0: RAM_0.self_t;
        mem1: RAM_0.self_t;
        \out\: DataWithIndex_3.self_t;
    end record;
    type BitreversalFFTshiftDecimate_0_self_t_list_t is array (natural range <>) of BitreversalFFTshiftDecimate_0.self_t;

    type self_t_const is record
        DECIMATION: integer;
        DECIMATION_BITS: integer;
        FFT_SIZE: integer;
        LUT: Typedefs.integer_list_t(0 to 8191);
        mem0: RAM_0.self_t_const;
        mem1: RAM_0.self_t_const;
        \out\: DataWithIndex_3.self_t_const;
        DELAY: integer;
    end record;
    type BitreversalFFTshiftDecimate_0_self_t_const_list_t_const is array (natural range <>) of BitreversalFFTshiftDecimate_0.self_t_const;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataWithIndex_3.self_t; ret_0:out DataWithIndex_3.self_t);
    function BitreversalFFTshiftDecimate(state: boolean; mem0: RAM_0.self_t; mem1: RAM_0.self_t; \out\: DataWithIndex_3.self_t) return self_t;
end package;

package body BitreversalFFTshiftDecimate_0 is
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; inp: DataWithIndex_3.self_t; ret_0:out DataWithIndex_3.self_t) is

        variable \out\: DataWithIndex_3.self_t;
        variable res: sfixed(0 downto -35);
        variable read: sfixed(0 downto -35);
        variable write_index_future: integer;
        variable write_index: integer;
        variable pyha_ret_0: sfixed(0 downto -35);
        variable pyha_ret_1: sfixed(0 downto -35);
        variable pyha_ret_2: sfixed(0 downto -35);
        variable pyha_ret_3: sfixed(0 downto -35);
        variable pyha_ret_4: sfixed(0 downto -35);
        variable pyha_ret_5: sfixed(0 downto -35);
    begin
        write_index := self_const.LUT(inp.index);
        write_index_future := self_const.LUT((inp.index + 1) mod self_const.FFT_SIZE);

        if self.state then
            RAM_0.delayed_read(self.mem0, self_next.mem0, self_const.mem0, write_index_future, pyha_ret_0);
            read := resize(pyha_ret_0, 0, -35, fixed_wrap, fixed_truncate);
            if inp.index = 0 then
                read := Sfix(0.0, 0, -35);
            end if;
            res := resize(resize(read + (inp.data sra self_const.DECIMATION_BITS), 0, -35, overflow_style=>fixed_wrap, round_style=>fixed_truncate), 0, -35, fixed_wrap, fixed_truncate);
            RAM_0.delayed_write(self.mem0, self_next.mem0, self_const.mem0, write_index, res);

            if inp.index < self_const.FFT_SIZE / self_const.DECIMATION then
                RAM_0.delayed_read(self.mem1, self_next.mem1, self_const.mem1, inp.index, pyha_ret_1);
                read := resize(pyha_ret_1, 0, -35, fixed_wrap, fixed_truncate);
                if True then
                    self_next.\out\.data := resize(read, 0, -35, fixed_wrap, fixed_truncate);
                    self_next.\out\.index := inp.index;
                    self_next.\out\.valid := True;
                end if;
                res := resize(Sfix(0.0, 0, -35, overflow_style=>fixed_wrap, round_style=>fixed_truncate), 0, -35, fixed_wrap, fixed_truncate);
                RAM_0.delayed_write(self.mem1, self_next.mem1, self_const.mem1, inp.index, res);
                -- self.out = DataWithIndex(self.mem1[inp.index] >> self.DECIMATION_BITS, index=inp.index, valid=True)
                -- self.mem1[inp.index] = 0.0
            else
                self_next.\out\.valid := False;

            end if;
        else
            RAM_0.delayed_read(self.mem1, self_next.mem1, self_const.mem1, write_index_future, pyha_ret_2);
            read := resize(pyha_ret_2, 0, -35, fixed_wrap, fixed_truncate);
            if inp.index = 0 then
                read := Sfix(0.0, 0, -35);
            end if;
            res := resize(resize(read + (inp.data sra self_const.DECIMATION_BITS), 0, -35, overflow_style=>fixed_wrap, round_style=>fixed_truncate), 0, -35, fixed_wrap, fixed_truncate);
            RAM_0.delayed_write(self.mem1, self_next.mem1, self_const.mem1, write_index, res);
            if inp.index < self_const.FFT_SIZE / self_const.DECIMATION then
                RAM_0.delayed_read(self.mem0, self_next.mem0, self_const.mem0, inp.index, pyha_ret_3);
                read := resize(pyha_ret_3, 0, -35, fixed_wrap, fixed_truncate);
                if True then
                    self_next.\out\.data := resize(read, 0, -35, fixed_wrap, fixed_truncate);
                    self_next.\out\.index := inp.index;
                    self_next.\out\.valid := True;
                end if;
                res := resize(Sfix(0.0, 0, -35, overflow_style=>fixed_wrap, round_style=>fixed_truncate), 0, -35, fixed_wrap, fixed_truncate);
                RAM_0.delayed_write(self.mem0, self_next.mem0, self_const.mem0, inp.index, res);
                -- self.out = DataWithIndex(self.mem0[inp.index] >> self.DECIMATION_BITS, index=inp.index, valid=True)
                -- self.mem0[inp.index] = 0.0
            else
                self_next.\out\.valid := False;

            end if;
        end if;
        if inp.index = self_const.FFT_SIZE - 1 then
            self_next.state := not self.state;
            -- self.read = Sfix(0.0, self.DECIMATION_BITS, -17)

            -- return self.out
        end if;
        if True then
            \out\.data := resize(read, 0, -35, fixed_wrap, fixed_truncate);
            \out\.index := self.\out\.index;
            \out\.valid := self.\out\.valid;
        end if;
        if self.state then
            RAM_0.get_readregister(self.mem1, self_next.mem1, self_const.mem1, pyha_ret_4);
            \out\.data := resize(pyha_ret_4, 0, -35, fixed_wrap, fixed_truncate);
        else
            RAM_0.get_readregister(self.mem0, self_next.mem0, self_const.mem0, pyha_ret_5);
            \out\.data := resize(pyha_ret_5, 0, -35, fixed_wrap, fixed_truncate);

        end if;
        ret_0 := \out\;
        return;
    end procedure;

    function BitreversalFFTshiftDecimate(state: boolean; mem0: RAM_0.self_t; mem1: RAM_0.self_t; \out\: DataWithIndex_3.self_t) return self_t is
        -- limited constructor
        variable self: self_t;
    begin
        self.state := state;
        self.mem0 := mem0;
        self.mem1 := mem1;
        self.\out\ := \out\;
        return self;
    end function;
end package body;
